##  c语言中printf的各参数分布（摘录）

* 源代码

```c
#include<stdio.h> 
void main()	{				
	printf("%s	%d	%s",	"Hello	World!",	233,	"\n"); 
}
```

* 栈分布(进入函数前的参数分布)

```assembly
0000|	0xffffd220	-->	0x5655561f	("%s   %d	%s") 
0004|	0xffffd224	-->	0x56555612	("Hello	World!") 
0008|	0xffffd228	-->	0xe9   		(223)
0012|	0xffffd22c	-->	0x56555610	-->	0x6548000a	('\n') 
0016|	0xffffd230	-->	0xffffd250	-->	0x1 
0020|	0xffffd234	-->	0x0 
0024|	0xffffd238	-->	0x0 
0028|	0xffffd23c	-->	0xf7df1253	(<__libc_start_main+243>:	add(esp,0x10)	

```

* 根据cdecl的调用约定，在进入printf()函数之前，将参数从右到左依次压 栈。进入printf()之后，函数首先获取第一个参数，一次读取一个字符。如果字符不是%，字符直接复制到输出中。否则，读取下一个非空字符，获取相应的参数并解析输出。（注意：%  d和%d是一样的）

* 接下来我们修改一下上面的程序，给格式字符串加上		%x	%x	%x	%1$s	，使它出现 格式化字符串漏洞：

```c
#include<stdio.h> 
void main()	{			
	printf("%s	%d	%s	%x	%x	%x	%1$s",	"Hello	World!",	233,	"\n");
}

```



* 栈分布

```
0000|	0xffffd220	-->	0x5655561f	("%s %d	%s	%x	%x	%x	%3$s") 
0004|	0xffffd224	-->	0x56555612	("Hello	World!") 
0008|	0xffffd228	-->	0xe9 
0012|	0xffffd22c	-->	0x56555610	-->	0x6548000a	('\n') 
0016|	0xffffd230	-->	0xffffd250	-->	0x1 
0020|	0xffffd234	-->	0x0 
0024|	0xffffd238	-->	0x0 
0028|	0xffffd23c	-->	0xf7df1253	(<__libc_start_main+243>: add(esp,0x10) 
```

* 这一次栈的结构和上一次相同，只是格式字符串有变化。程序打印出了七个值（包 括换行），而我们其实只给出了前三个值的内容，后面的三个%x打印出了0xffffd230~0xffffd238栈内的数据，这些都不是我们输入的。而最后一个参 数%3$s是对0xffffd22c中\n的重用。

  ![image-20200310122039552](\static\blog_md\md_img\yx-3-1.png)

  

  * 为什么可以通过编译？ 

    因为printf()函数的参数被定义为可变的。 为了发现不匹配的情况，编译器需要理解printf()是怎么工作的和格 式字符串是什么。然而，编译器并不知道这些。 有时格式字符串并不是固定的，它可能在程序执行中动态生成。	

  * printf()函数自己可以发现不匹配吗？

    ​	printf()函数从栈中取出参数，如果它需要3个，那它就取出3个。 除非栈的边界被标记了，否则printf()是不会知道它取出的参数比提 供给它的参数多了。然而并没有这样的标记。

## 格式化字符串漏洞利用